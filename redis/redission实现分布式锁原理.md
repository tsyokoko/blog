## Redission实现分布式锁原理

**一、高效分布式锁**

高效分布式锁需要考虑的问题：

- **互斥**

  在分布式高并发的条件下，我们最需要保证，同一时刻只能有一个线程获得锁，这是最基本的一点。

- **防止死锁**

  在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它线程都无法获得锁，造成死锁。所以分布式非常有必要设置锁的 `有效时间 `，确保系统出现故障后，在一定时间内能够主动去释放锁，避免造成死锁的情况。

- **性能**

  对于访问量大的共享资源，需要考虑减少锁等待的时间，避免导致大量线程阻塞。所以在锁的设计时，需要考虑两点:

  1. **锁的颗粒度要尽量小**
     比如你要通过锁来减库存，那这个锁的名称你可以设置成是商品的ID,而不是任取名称。这样这个锁只对当前商品有效,锁的颗粒度小。

  1. **锁的范围尽量要小** 

     比如只要锁2行代码就可以解决问题的，那就不要去锁10行代码了。

- **重入**

  我们知道ReentrantLock是可重入锁，那它的特点就是：同一个线程可以重复拿到同一个资源的锁。重入锁非常有利于资源的高效利用。

针对以上Redisson都能很好的满足，下面就来分析下它。

**二、Redisson原理分析**

![preview](/Users/mbpzy/images/view.jpeg)

### 1.加锁机制

线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。

线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。

### 2.watch dog自动延期机制

这个比较难理解，找了些许资料感觉也并没有解释的很清楚。这里我自己的理解就是:

在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(不设置默认30秒），这样的目的主要是防止死锁的发生。

但在实际开发中会有下面一种情况:

```java
            //设置锁1秒过去
            redissonLock.lock("redisson", 1);
            /**
             * 业务逻辑需要咨询2秒
             */
            redissonLock.release("redisson");
    
          /**
           * 线程1 进来获得锁后，线程一切正常并没有宕机，但它的业务逻辑需要执行2秒，这就会有个问题，在 线程1 执行1秒后，这个锁就自动过期了，那么这个时候 线程2 进来了。那么就存在 线程1和线程2 同时在这段业务逻辑里执行代码，这当然是不合理的。而且如果是这种情况，那么在解锁时系统会抛异常，因为解锁和加锁已经不是同一线程了.
           */
    
```

所以这个时候 `看门狗 `就出现了，它的作用就是 线程1 业务还没有执行完，时间就过了，线程1 还想持有锁的话，就会启动一个watch dog后台线程，不断的延长锁key的生存时间。

`注意 `正常这个看门狗线程是不启动的，还有就是这个看门狗启动后对整体性能也会有一定影响，所以不建议开启看门狗。

### 3.为啥要用lua脚本呢？

这个不用多说，主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性 。

### 4.可重入加锁机制

Redisson可以实现可重入加锁机制的原因，我觉得跟两点有关：

```mathematica
    1.Redis存储锁的数据类型是 Hash类型
    2.Hash数据类型的key值包含了当前线程信息。
```

下面是redis存储的数据
![img](/Users/mbpzy/images/1460000022355786.jpeg)

这里表面数据类型是Hash类型,Hash类型相当于我们java的 `<key,<key1,value>> `类型,这里key是指 'redisson'，它的有效期还有9秒，我们再来看里们的key1值为 `078e44a3-5f95-4e24-b6aa-80684655a15a:45 `它的组成是guid + 当前线程的ID。后面的value是就和可重入加锁有关。

**举图说明**

![img](/Users/mbpzy/images/1460000022355787.jpeg)

上面这图的意思就是可重入锁的机制，它最大的优点就是相同线程不需要在等待锁，而是可以直接进行相应操作。

### 5.Redis分布式锁的缺点

Redis分布式锁会有个缺陷，就是在Redis哨兵模式下:

`客户端1 `对某个 `master`节点 写入了redisson锁，此时会异步复制给对应的` slave`节点。但是这个过程中一旦发生`master`节点宕机，主备切换，`slave`节点从变为了 `master`节点。

这时 `客户端2 `来尝试加锁的时候，在新的`master`节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。

这时系统在业务语义上一定会出现问题， **导致各种脏数据的产生** 。

`缺陷 `在哨兵模式或者主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁。