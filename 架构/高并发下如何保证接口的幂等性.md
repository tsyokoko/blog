## 面试官：高并发下如何保证接口的幂等性？

![面试官：高并发下如何保证接口的幂等性？](https://tsyokoko-typora-images.oss-cn-shanghai.aliyuncs.com/img/v2-8dd1413c7a1955ceb765a8a866892d4c_720w.jpg)

前言接口幂等性问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。不知道你有没有遇到过这些场景：

有时我们在填写某些form表单时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。我们在项目中为了解决接口超时问题，通常会引入了重试机制。

第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果（这种情况不可能直接返回失败吧？），于是会对该请求重试几次，这样也会产生重复的数据。

mq消费者在读取消息时，有时候会读取到重复消息（至于什么原因这里先不说，有兴趣的小伙伴，可以找我私聊），如果处理不好，也会产生重复的数据。

没错，这些都是幂等性问题。接口幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。

这类问题多发于接口的：

insert操作，这种情况下多次请求，可能会产生重复数据。

update操作，如果只是单纯的更新数据，比如：update user set status=1 where id=1，是没有问题的。如果还有计算，比如：update user set status=status+1 where id=1，这种情况下多次请求，可能会导致数据错误。

### 1.insert前先select

通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在insert前，先根据name或code字段select一下数据。如果该数据已存在，则执行update操作，如果不存在，才执行 insert操作。
![img](/Users/mbpzy/images/v2-cfa293f156300a770c27f879d9341266_b.jpg)

该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。

我在这里提一下，是为了避免大家踩坑。

### 2.加悲观锁

在支付场景中，用户A的账号余额有150元，想转出100元，正常情况下用户A的余额只剩50元。一般情况下，sql是这样的：

`update user amount = amount-100 where id=123;`

如果出现多次相同的请求，可能会导致用户A的余额变成负数。这种情况，用户A来可能要哭了。于此同时，系统开发人员可能也要哭了，因为这是很严重的系统bug。为了解决这个问题，可以加悲观锁，将用户A的那行数据锁住，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。通常情况下通过如下sql锁住单行数据：

`select * from user id=123 for update;`

具体流程如下：
![img](/Users/mbpzy/images/v2-d65355e1ff223baaaa1cf0f2a6d15196_b.jpg)
具体步骤：

多个请求同时根据id查询用户信息。判断余额是否不足100，如果余额不足，则直接返回余额不足。如果余额充足，则通过for update再次查询用户信息，并且尝试获取锁。

只有第一个请求能获取到行锁，其余没有获取锁的请求，则等待下一次获取锁的机会。第一个请求获取到锁之后，判断余额是否不足100，如果余额足够，则进行update操作。如果余额不足，说明是重复请求，则直接返回成功。

需要特别注意的是：如果使用的是mysql数据库，存储引擎必须用innodb，因为它才支持事务。此外，这里id字段一定要是主键或者唯一索引，不然会锁住整张表。悲观锁需要在同一个事务操作过程中锁住一行数据，如果事务耗时比较长，会造成大量的请求等待，影响接口性能。此外，每次请求接口很难保证都有相同的返回值，所以不适合幂等性设计场景，但是在防重场景中是可以的使用的。

在这里顺便说一下，防重设计 和 幂等设计，其实是有区别的。防重设计主要为了避免产生重复数据，对接口返回没有太多要求。而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。

### 3.加乐观锁

既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个timestamp或者version字段，这里以version字段为例。在更新数据之前先查询一下数据：

```sql
select id,amount,version from user id=123;
```

如果数据存在，假设查到的version等于1，再使用id和version字段作为查询条件更新数据：

```sql
update user set amount=amount+100,version=version+1 where id=123 and version=1;
```

更新数据的同时version+1，然后判断本次update操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。由于第一次请求version等于1是可以成功的，操作成功后version变成2了。这时如果并发的请求过来，再执行相同的sql：

```sql
update user set amount=amount+100,version=version+1 where id=123 and version=1;
```

当扣减时，支持高并发的乐观锁是: 

```sql
update user set amount = amount-100 where id=123 and amount >= 100 
```

这样必须要先 select 再 update(千万不要使用 WHERE amount - 100 >= 0 因为 遇到 unsigned 的字段会因为计算结果是负数导致报错)

该update操作不会真正更新数据，最终sql的执行结果影响行数是0，因为version已经变成2了，where中的version=1肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为version值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求具体流程如下：
![img](/Users/mbpzy/images/v2-14749e8e99c022c968686658797f024d_b.jpg)
具体步骤：先根据id查询用户信息，包含version字段根据id和version字段值作为where条件的参数，更新用户信息，同时version+1判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。如果影响0行，说明是重复请求，则直接返回成功。

### 4.加唯一主键

绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。

```sql
alter table order add UNIQUE KEY un_code (code);
```

加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报	`Duplicate entry '002' for key 'order.un_code`异常，表示唯一索引有冲突,使用

```sql
 insert ignore into 
```

 可以避免捕获 DuplicateKeyException

### 5.建防重表

有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。针对这种情况，我们可以通过建防重表来解决问题。

该表可以只包含两个字段：id 和 唯一索引，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：susan_0001。具体流程图如下：
![img](/Users/mbpzy/images/v2-b22205056919bf37a8f196a6b72aa56b_b.jpg)

具体步骤：用户通过浏览器发起请求，服务端收集数据。将该数据插入mysql防重表判断是否执行成功，如果成功，则做mysql其他的数据操作（可能还有其他的业务逻辑)。如果执行失败，捕获唯一索引冲突异常，直接返回成功。

需要特别注意的是：防重表和业务表必须在同一个数据库中，并且操作要在同一个事务中。

### 6.根据状态机

很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。

如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。假如id=123的订单状态是已支付，现在要变成完成状态。

```sql
update order set status=3 where id=123 and status=2;`
```

第一次请求时，该订单的状态是已支付，值是2，所以该update语句可以正常更新数据，sql执行结果的影响行数是1，订单状态变成了3。

后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了3，再用status=2作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是0，即不会真正的更新数据。

但为了保证接口幂等性，影响行数是0时，接口也可以直接返回成功。具体流程图如下：
![img](/Users/mbpzy/images/v2-8e5457376233540186b52d593a088394_b.jpg)

具体步骤：用户通过浏览器发起请求，服务端收集数据。根据id和当前状态作为条件，更新成下一个状态判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。如果影响了0行，说明是重复请求，直接返回成功。主要特别注意的是，该方案仅限于要更新的表有状态字段，并且刚好要更新状态字段的这种特殊情况，并非所有场景都适用。

### 7.加分布式锁

其实前面介绍过的加唯一索引或者加防重表，本质是使用了数据库的分布式锁，也属于分布式锁的一种。但由于数据库分布式锁的性能不太好，我们可以改用：redis或zookeeper。鉴于现在很多公司分布式配置中心改用apollo或nacos，已经很少用zookeeper了，我们以redis为例介绍分布式锁。

目前主要有三种方式实现redis的分布式锁：

setNx命令、set命令、Redission框架每种方案各有利弊，具体实现细节我就不说了。

具体流程图如下：
![img](/Users/mbpzy/images/v2-c0945c6b3b22131f8504481a9e247a9a_b.jpg)

具体步骤：用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。如果设置失败，说明是重复请求，则直接返回成功。需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费redis的存储空间，需要根据实际业务情况而定。

### 8.获取token

除了上述方案之外，还有最后一种使用token的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。第一次请求获取token第二次请求带着这个token，完成业务操作。具体流程图如下：第一步，先获取token。
![img](/Users/mbpzy/images/v2-2a26b03d3515e3d1d295a2b29d6a4b2d_b.jpg)
第二步，做具体业务操作。
![img](/Users/mbpzy/Downloads/%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9/md/%25E6%25AF%258F%25E6%2597%25A5%25E7%25AC%2594%25E8%25AE%25B0.assets/v2-1e92f871db1d7b42dffd7e67e37552d4_b.jpg)
具体步骤：用户访问页面时，浏览器自动发起获取token请求。服务端生成token，保存到redis中，然后返回给浏览器。用户通过浏览器发起请求时，携带该token。在redis中查询该token是否存在，如果不存在，说明是第一次请求，做则后续的数据操作。如果存在，说明是重复请求，则直接返回成功。在redis中token会在过期时间之后，被自动删除。以上方案是针对幂等设计的。如果是防重设计，流程图要改改：
![img](/Users/mbpzy/Downloads/%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9/md/%25E6%25AF%258F%25E6%2597%25A5%25E7%25AC%2594%25E8%25AE%25B0.assets/v2-08d6b711a00d7bee3f20d9826b549e59_b.jpg)什么是幂等性



在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的。

**举几个简单的例子：**

1. 前端对同一表单数据的重复提交，后台应该只会产生一个结果
1. 我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱
1. 发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃
1. 创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单

### 9.如何保证幂等性

幂等性需要通过唯一的业务单号来保证，也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保后面的多次相同的业务处理逻辑和执行效果是一致的。以支付为例，在不考虑并发的情况下，实现业务的幂等性分两个流程：

1. 先查询订单是否已经支付过
1. 如果支付过，则返回支付成功；如果没有支付，则进行支付流程，修改订单业务为**已支付**

这个方案是分成两步的，步骤 2 依赖于步骤 1 的结果，无法保证原子性。在并发环境下，假设现在请求 A 查询到订单没有支付，执行支付流程，执行完毕后，还没有修改订单状态时，由于重复提交，请求 B 查询订单状态得出未支付的结论，进行支付流程。这样对于同一个订单相当于支付了两次，是不符合幂等性的。

知道为什么破坏了幂等性，余下为问题也很简单：**将查询和更改状态操作加锁，将并行操作更改为串行操作**

##### 幂等性实现方案

##### **乐观锁**

如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。

##### **防重表**

使用订单号 orderNo 做为去重表的唯一索引，每次请求都根据订单号向去重表中插入一条数据。第一次请求查询订单支付状态，订单没有支付，进行支付操作，无论成功与否，执行完后更新订单状态为成功或失败，删除去重表中的数据。后续的订单因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成（成功或失败）。

![img](/Users/mbpzy/images/%E5%B9%82%E7%AD%89%E6%80%A7.png)

##### 分布式锁

对于防重表可以用分布式锁代替，比如 Redis 和 Zookeeper

**Redis**

1. 订单发起支付请求，支付系统会去 Redis 缓存中查询是否存在该订单号的 Key，如果不存在，则向 Redis 增加 Key 为订单号
1. 查询订单支付状态，如果未支付，则进行支付流程，支付完成后删除该订单号的 key

**Zookeeper**

1. 订单发起支付请求，支付系统会去 Zookeeper 中创建一个 node，如果创建失败，则表示订单已经被支付
1. 如果创建成功，则进行支付流程，支付完成后删除 node

##### Token 机制

这种方式分成两个阶段：申请 Token 阶段和支付阶段。 第一阶段，在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请 Token 的请求，支付系统将 Token 保存到 Redis 缓存中，为第二阶段支付使用。 第二阶段，订单系统拿着申请到的 Token 发起支付请求，支付系统会检查 Redis 中是否存在该 Token ，如果存在，表示第一次发起支付请求，删除缓存中 Token 后开始支付逻辑处理；如果缓存中不存在，表示非法请求。

##### 消息队列缓冲

将订单的支付请求全部发送到消息队列中，然后使用异步任务处理队列中的数据，过滤掉重复的待支付订单，再进行支付流程。