### ES与Mongodb的对比

ES是搜索引擎，不是存储引擎。（为什么叫创建index而不是table，也是这个原因）

ES存少量索引数据，数据特点（索引数据+需要聚合的数据），每个document尽量小。

那涉及的存储用什么，推荐NoSQL(eg: Hbase, mongodb).

每次ES索引，拿到Key，然后再反查key-value DB，效率完爆传统的关系型数据库。

ES的灵活性+HBase等大容量存储，这套组合，是比较优秀的企业查询解决方案。

ES是java编写，通过RESTFul接口操作数据，mongodb是C++编写，通过driver操作数据。（es对java开发更有好，利于排查理解）

mongodb的分片有hash和range两种方式，es只有hash一种。

es是天生分布式，主副分片自动分配和复制，开箱即用。mongodb的分布式是由“前置查询路由+配置服务+shard集合”，需要手动配置集群服务。

内部存储ES是倒排索引+doc values+field data。mongodb暂时未知。

es全文检索有强大的分析器且可以灵活组合，查询时智能匹配。mongodb的全文检索字段个数有限制。

es所有字段自动索引，mongodb的字段需要手动索引。

MySQL：关系型数据库，主要面向OLTP，支持事务，支持二级索引，支持sql，支持主从、Group Replication架构模型（本文全部以Innodb为例，不涉及别的存储引擎）。

ElasticSearch：ES是一款分布式的全文检索框架，底层基于Lucene实现，天然分布式，p2p架构，不支持事务，采用倒排索引提供全文检索。

#### ES与Mysql的对比

**存储方式**

MySQL中要提前定义表结构，也就是说表共有多少列（属性）需要提前定义好，并且同时需要定义好每个列所占用的存储空间。数据以行为单位组织在一起的，假如某一行的某一列没有数据，也需要占用存储空间。

ES:比较灵活，索引中的field类型可以提前定义（定义mapping），也可以不定义，如果不定义，会有一个默认类型，不过出于可控性考虑，关键字段最好提前定义好。不同的是，ES存的是倒排索引，

**读写方式**

Mysql :Innodb中主键即为聚簇索引，假如根据主键查询，聚簇索引的叶子节点存放就是真正的数据，可以直接查到相应的记录。

Es: 每个node都可以接收读request，然后该node会把request分发到含有该index的shard的节点上，对应的节点会查询、并计算出符合条件的文档，排序后结果汇聚到分发request的node（所以查询请求默认会轮循的将发送到各个节点上，防止请求全部打到一个节点），由该node将数据返回给client。

**数据量**

在面对大数据量简单计算的时候es的效率原高于mysql等传统数据库，

对于相对数量较少，多表join 时，mysql优势更高

**总结**

MySQL作为开源关系型数据库，应用范围非常广泛，非常适合于结构化数据存储和查询。在数据查询场景下，默认返回所有满足匹配条件的记录；如果业务数据为结构化数据，同时不需要特别关注排名和智能分词模糊匹配查询等特性，则建议采用关系型数据库如MySQL

ES作为新生代NoSQL数据库代表之一，非常适合于非结构化文档类数据存储、更创新支持智能分词匹配模糊查询。如果业务数据为非结构化数据，同时更关注排名和需要智能分词模糊匹配的特性，则建议采用非关系型数据库如ES作为数据存储介质并使用配套搜索引擎。

ES现在不仅提供全文检索，还提供统计功能，并且提供的Restful接口非常好用，配上Kibana还可以进行图形化展示，第三方插件也很丰富。虽然ES可以水平扩展，但是考虑到ES的大部分检索都会检索该index的所有shard，如果单个index数据过大，性能多少也会受到影响，所以单个index的大小最好控制在一定的范围，比如存储用户行为日志的index，可以每隔一段时间归一次档，创建新的index，做到冷热分离。而且ES也可以作为MySQL或HBase的索引来使用，虽然Mysql也有索引功能，但是过多的索引往往会拖累MySQL的性能，并且线上MySQL数据库一般也不允许执行统计类的sql，这时可以用ES辅助实现统计，HBase因为只有主键检索，所以更需要二级索引的功能。

举一个笔者前司组合使用的场景：trace系统的log数据以HBase作为主要存储，同时最近三个月的数据也在ES里面保留一份，ES主要用来完成各种复杂检索、统计。但数据同步需要业务自己实现，当然trace业务对一致性要求不那么高，也可以忽略这个问题。

*tip：将数据库的数据向ES中同步的时候，因为网络延迟等问题，到达的顺序可能会乱序，这时老数据有可能会覆盖新的数据，ES提供了一个version功能，可以将数据的timestamp作为version值，防止旧version的数据覆盖新version的数据。*



在存储上，mongodb和es是document格式的存储，mysql是行格式的，因此mongo和es并不需要显式定义字段，而mysql需要。

在架构上，es天然就是分布式的，这个可以很容易的横向扩容，而mongo和mysql不行。

在针对场景下，es无法做到实时，而mysql和mongo可以，因此mysql和mongo支持的oltp对于es而言需要额外考虑下场景是否适用，可以认为es同时具有oltp和olap的特点，但两边都不是特别突出。

在数据存储量及性能上，mysql由于其索引实现（innodb为例）导致在数据量大到一定级别后会出现性能衰减，而mongo和es只要给足足够内存就没太大问题（mongo内存不足时衰减的更为厉害，es不明）。插入速度上如果正确的配置mysql其性能并不低，当然相对于正常状态mongo和es而言还是差了一个到多个量级（es>mongo>mysql）。查询速度这个主要看索引和数量，这个不太好说，mongo谜一样的索引选择曾经让我纠结过很久，在需要复杂关联查询的时候建议优先考虑mysql。

资源开销上当数据量上去了后如果为了维持性能的话，es吃内存的能力绝对可以傲视群雄，但毕竟没有不吃草就能跑的快的马儿。

易用性上当然是mysql>mongo>es，如果考虑使用mysql的话可以再考虑下postgresql，虽然小众点，但有些mysql功能上的缺失会让你写sql写到哭。

全文索引是es的特点。

### 条目一：如果是创业初期，直接用最熟悉的数据库就好

比如MySQL。

这样的做是有好处的，就是糙快猛。创业初期，最重要的是把项目做出来并上线。业务能不能活下来还不一定呢，想太多高性能、高可靠、易运维的事都没有太大的意义。

简单可靠才是最需要关注的。

### 条目二：不建议使用MySQL的TEXT类型

像blob和text这样的字段，名义上是为存储很大的数据而设计的类型。但这正因为如此，这跟关系数据库使用table的设计理念是冲突的。table中的每一列数据都是定长的，比如`varchar(32)`。但blob和text的上限太长了，MySQL不可能将它们存储在table中，因而会使用专门的外部存储区域进行存储，数据行内存储指针。这样做的其中一个结果是会导到多一次磁盘IO，性能开销比较严重。

### 条目三：新闻类文本直接静态化扔Nginx或OSS就好

频繁读不频繁写的新闻资讯类文本，在保存的时候，直接写成静态的html，访问的时候直接从nginx返回。这样做，不仅可以节省服务器资源，还可以利用CDN加速，把文件放到离用户最近的CDN服务器上，既便宜又快。

OSS是另一个可选的方案。OSS的优势是对图片和视频存储做了大师针对性优化，比如缩放图片和视频转码。另外，几乎所有的OSS云服务都自带CDN加速服务。

熟悉程度和价格可能仍然是很重要的选择因素。

### 条目四：笔记类产品MongoDB可能是个不错的选择

简述MongoDB的特点如下：

1. 偶尔丢数据：在开发者水平相当的情况下，MongoDB更容易鼓励开发者做出不恰当的设计从而导致数据丢失。如果你的数据特别重要（金融、交易），那么关系型数据库可能是个更好的选择。对笔记类产品吧，可能没那么疼，忍一忍就过去了。
1. 无schema：不需要预定义的schema，以文档（json, bson）形式保存数据，同一个集合（对应关系数据库的表）中的不同文档可以使用不同的结构，并支持随时向扩展任意字段。这个特点导致MongoDB特别适合存储商品参数这类名目繁多又不尽相同的参数。在在**游戏、电商、社交、直播、物流**等领域都能看到MongoDB的身影。
   当然，随之而来的问题就是如果代码结构不够清晰，很可能导致没有任何人知道数据库中存储的数据是什么格式。对接手他人代码的人员，如果不能确定文档中有哪些字段 ，则可能导致相当危险的结果。如果你的数据模式比较固定的话，一个变通的方案是通过protobuf这种序列化协议引入外部模式。
   这对笔记类产品谈不上好或者坏，毕竟笔记的主要内容是大段不需要解析的文本。
1. 单文档查询速度快：MongoDB使用BTree结构（对比MySQL使用B+Tree），针对单文档的查询做了大量节约IO的优化，因此查询速度很快，当然吃内存也是毫不含糊。 修订：MongoDB使用的也是B+Tree，原来的理解有误。
1. 多表联查功能弱：笔记产品不太需要。
1. 事务功能弱：4.0以上的版本已经支持基于Replica Set的事务，但在此之前只支持单文档的原子操作。对笔记来产品来说，弱化事务的使用可以提高数据写入效率。
1. 提供全文索引，这个对笔记类搜索有用（但中文支持弱不少 = = ）。
1. 原生支持sharding（分片），升级数据库容量时分片间的数据可以自动迁移，这对海量数据的扩容简直不要太nice。

### 条目五：其它数据库产品

1. MySQL，关系数据库，强在事务和关联查询
1. Redis/Memcache，内存数据库，主要用作缓存，不适用于长文本处理
1. ElasticSearch，全文搜索，虽然楼主没提，但在笔记类产品的确有这种需求。但仔细想一下，个人笔记量是否真的需要上ES才能满足需要呢？