# 传统事务与柔性事务

柔性事务之前我们先来回归传统事务

##### 传统事务

第一次接触事务的时候，被人告知事务是原子的，要么都成功要么都失败。再进一步就有ACID这四个属性，原子性（Atomictiy）、一致性（Consistency）、隔离性（Isolation）、持久性（Durabilit）。

我们首先看下一些书籍中的官方描述：

| 原子性 | 事务是一个包含一系列操作的原子操作。事务的原子性确保这些操作全部完成或者全部失败。 |
| ------ | ------------------------------------------------------------ |
| 一致性 | 一旦事务的所有操作结束，事务就被提交。然后你的数据和资源将处于遵循业务规则的一直状态。 |
| 隔离性 | 因为同时在相同数据集上可能有许多事务处理，每个事务应该与其他事务隔离，避免数据破坏。 |
| 持久性 | 一旦事务完成，他的结果应该能够承受任何系统错误（想象一下在事务提交过程中机器的电源被切断的情况）。通常，事务的结果被写入持续性存储 |

《Spring攻略》中的官方描述：

| 原子性 | 在一个事务里的动作序列的每一个步骤都必须是要么全部成功，要么所有的工作都将回滚。部分完成不是一个事务的概念。 |
| ------ | ------------------------------------------------------------ |
| 一致性 | 在事务开始和完成的时候，系统的资源都必须处于一致的、没有被破坏的状态。 |
| 隔离性 | 一个事务，直到它被成功提交之后，它的结果对于任何其他的事务才是可见的。 |
| 持久性 | 一个已提交事务的任何结果都必须是永久性的，即“在任何系统崩溃的情况下都能保存下来”。 |

OK，那这四个属性，我们自己到底该如何理解呢。个人理解如下：如果给事务下一个定义：事务是一个有边界的工作序列，开始和结束都有明确的定义。

| 性质   | 具体内容                                                     |
| ------ | ------------------------------------------------------------ |
| 原子性 | 举例1：比如现在有一个事务，包含3个sql语句（工作序列，或者是指令序列），sql-1，sql-2，sql-3，这3个sql语句，每一个在执行的时候，都是一个单元，这个单元的执行结果，有且仅有两种可能：成功和失败。<br/>		举例2：再比如，我从账户1中转出1000人民币到账户2，当我从账户1中把钱转出来之后，系统就崩溃了。那么系统应该将我的账户状态置成我还没有转出钱之前的状态。 |
| 一致性 | 举例1：有一个在线商务网站系统，有两张表，一张用户账户表（用户名、个人余额），一张商品库存表（商品ID，库存数量），用户花费30元购买1件商品，商品库存减1，账户余额减30.那么这样的结果就是一致的。否则，如果商品库存减1，账户余额没有变化，那么这样的结果就是不一致的。<br/>		举例2：银行账户转账的例子，也一样，账户1中的钱减少1000，账户2中的钱就增加1000，这样的是一致的，否则不一致。 |
| 隔离性 | 没有隔离性就没有一致性<br/>		举例1：我们现在有两个事务方法，一个方法是查询数据的库存，一个是购买下单，那么这两个事务方法应该互不影响，不然会造成一系列的问题，个人一直认为，事务造成的下面这些问题是跟并发密不可分的，没有并发操作，单一的请求事务是不会有这样的问题的。并发事务产生的问题可以分为4类：“读脏数据、不可重复读、幻读、更新丢失”，是不是跟并发导致的问题一直的呢。其实在《企业应用架构模式》一书中，有一句话描述就是：处理并发最主要的工具就是事务。 |
| 持久性 | 对于数据库来讲，我的理解是这样，当我把sql-1、sql-2、sql-3提交之后，这个结果就一定会保存到数据库中，那如果提交-到写入这中间，突然断电，也没有关系，数据库服务器在重新启动之后一样会把数据写入磁盘，应该是通过日志的方式-仅个人理解。<br/>		数据库一般都是通过事务日志的方式，write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动数据库，首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性. |

##### 柔性事务

在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下BASE理论，它是在CAP理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。

**基本可用**：分布式系统出现故障的时候，允许损失一部分可用性。比如，京东618大促的时候，对一些非核心链路的功能进行降级处理。

**柔性状态**：允许系统存在中间状态，这个中间状态又不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，这样实际是一种柔性状态。

**最终一致性：**那上面数据库主从复制的例子，经过数据同步延时之后，最终数据能达到一致。

ACID是传统数据库常用的设计思想，它追求的是强一致性。BASE是大型分布式系统场景下的设计思想，通过牺牲强一致性获得高可用性。

柔性事务是在互联网的各种应用场景下产生的，互联网最核心的需求是什么？高可用。比如每年的京东618大促，交易高峰期间如果有10S不可用，那么损失的订单量大家可想而知。

老的方式实现分布式事务是通过两阶段提交来实现的，分为准备阶段和提交阶段。

两阶段事务的关键是在准备阶段，在这个阶段所有参与者必须完成约束检查，达成关于分布式事务一致性的共识。第二阶段，根据之前达成的共识，完成相应的操作。提交事务的过程中需要在很多个资源节点之间进行协调，而且每个节点对锁资源的释放必须等到事务最终提交的时候。这样两阶段事务提交会耗费更长的时间。事务执行时间长意味着锁资源发生冲突的概率增加，当事务的并发量积累到一定数量的时候，很可能出现事务积压甚至出现死锁。系统的性能和吞吐量就会下降。

**柔性事务针对分布式事务的解决方法：**

 1、记录日志+补偿

 记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是反向补偿。

2、消息

多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。

 3、“无锁”设计

放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。

```sql
 update goods
 set `name`=#{name},
 remaining_number=#{remainingNumber},
 version=version+1
 where id=#{id} and version=#{version}
```

##### 总结

从理念上梳理了传统事务和柔性事务。在现在的电商领域里绝大部分场景下，我们都不会使用两阶段提交这样低效的方式来实现分布式事务。我们都会采取上面柔性事务的方式来实现分布式事务来保证系统的性能和业务的最终一致。柔性事务的实现需要有下面2点作为保证：

 1、应用程序一定要做幂等实现，特别是对数据库进行数据修改操作的时候。

2、远程模块之间采用异步消息驱动，异步消息还可以起到检查点的作用。

