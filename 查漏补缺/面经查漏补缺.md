##### 1、Java三大特性

​	封装、继承、多态

##### 2、对象的四种引用

- 强引用：只要引用存在，垃圾回收器永远不会回收
- 软引用：非必须引用，内存溢出之前进行回收
- 弱引用：第二次垃圾回收时回收
- 虚引用：垃圾回收时回收，无法通过引用取到对象值

##### 3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？

很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。

##### 4.为什么要重写**hashcode**和**equals**方法？

默认的equals方法是Object的方法，比较的是内存地址，不同的key可以算出相同的hashcode

##### 5.Java反射机制与获取反射的三种方法

对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法，通过new对象 、路径、类名实现反射机制

##### 6.final finally finalize

ﬁnal可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 

ﬁnally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法ﬁnally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

 ﬁnalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用 System.gc() 方法的时候，由垃圾回收器调用ﬁnalize()，回收垃圾，一个对象是否可回收的 最后判断。

##### 7.Java中异常的分类以及处理机制

![image-20210803012055716](https://tsyokoko-typora-images.oss-cn-shanghai.aliyuncs.com/img/image-20210803012055716.png)

##### 8.String str="i"与 String str=new String(“i”)一样吗？

不一样，因为内存的分配方式不一样。==String str="i"==的方式，Java 虚拟机会将其分配到==常量池==中；而 ==String str=new String(“i”)== 则会被分到==堆内存==中。

##### 11. 抽象类必须要有抽象方法吗？

不需要，==抽象类不一定非要有抽象方法==。

##### 14.接口和抽象类有什么区别？

- 默认方法实现：抽象类可以有默认的方法实现；接口不能有默认的方法实现。
- 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
- 构造函数：==抽象类可以有构造函数==；接口不能有。
- main 方法：==抽象类可以有 main 方法，并且我们能运行它==；接口不能有 main 方法。
- 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
- 访问修饰符：==接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。==

##### 16.BIO、NIO、AIO 有什么区别？

- BIO：Block IO 同步==阻塞==式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
- NIO：New IO 同步==非阻塞== IO，是传统 IO 的升级，客户端和服务器端通过==Channel（通道）通讯==，实现了多路复用。
- AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了==异步非堵塞== IO ，异步 IO 的操作基于事件和回调机制。

##### 18.Java 容器都有哪些？

Java 容器分为 Collection 和 Map 两大类：

- Collection
  - List、ArrayList、LinkedList、Vector、Stack、Set、HashSet、LinkedHashSet、TreeSet
- Map
  - HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable

##### 19.HashSet 是如何保证不重复的

向 HashSet 中 add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合 equals 方法比较

##### 20.综合性HashMap底层问题

<img src="https://tsyokoko-typora-images.oss-cn-shanghai.aliyuncs.com/img/image-20210807161415650.png" alt="image-20210807161415650" style="zoom:50%;" />

<img src="https://tsyokoko-typora-images.oss-cn-shanghai.aliyuncs.com/img/image-20210924103515064.png" alt="image-20210924103515064" style="zoom:50%;" />

<img src="https://tsyokoko-typora-images.oss-cn-shanghai.aliyuncs.com/img/image-20210807161511390.png" alt="image-20210807161511390" style="zoom:50%;" />

##### 21.HashMap 和 Hashtable 有什么区别？

- 存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。
- 线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。
- 推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。

##### 22.HashMap 是线程安全的吗，为什么不是线程安全的

- JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。
- JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。

##### 23.HashMap 的扩容过程

当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值则自动扩容

##### 24.你都知道哪些常用的Map集合? 

- HashMap
- LinkedHashMap
  	比 HashMap 多维护了一个双向链表，因此可以按照插入的顺序从头部或者从尾部迭代，是有序的
- TreeMap：
  	TreeMap 的底层就是一颗红黑树
- Hashtable：
  	HashTable是线程安全的HashMap，里面的方法都是用synchronized修饰过的，跟HashMap有以下不同之处：
  - 初始容量不同，HashMap是16，HashTable是11；
  - HashMap可以存储值为null的元素，而HashTable不可以；
  - HashMap的迭代器是基于快速失败(modCount)机制，fail-fast，而HashTable的迭代器不是快速失败的。
- ConcurrentHashMap

##### 25.讲一讲基本数据类型与其包装类

int，float 占用 4 个字节，short\char 占用 2 个字节，long 占用 8 个字节，byte/boolean 占用 1 个字节

基本数据类型存放在栈里，包装类栈里存放的是对象的引用，即值的地址，而值存放在堆里。

以int 与 integer 的区别为例：
		Integer是int的包装类，int则是java的一种基本数据类型
		Integer变量必须实例化后才能使用，而int变量不需要
		Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值
		Integer的默认值是null，int的默认值是0

由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。

Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）

==非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）==

==对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false==

##### 27. ArrayList 和 Vector 的区别是什么？

- 线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
- 性能：ArrayList 在性能方面要优于 Vector。
- 扩容：==ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。==

##### 29. 在 Queue 中 poll()和 remove()有什么区别？

- 相同点：都是返回第一个元素，并在队列中删除返回的对象。
- 不同点：==如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。==

##### 30. 哪些集合类是线程安全的？

Vector、Hashtable、Stack 都是线程安全的

##### 31.Arrays.sort 和 Collections.sort 实现原理和区别

事实上Collections.sort方法底层就是调用的Arrays.sort方法，不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来

##### 32.什么是内部类？内部类的作用

内部类指在类的内部再定义另一个类。实现多重继承 实现隐藏

成员内部类，静态内部类，匿名内部类，局部内部类

##### 33.父类的静态方法能否被子类重写？静态属性和静态方法是否可以被继承？

父类的静态方法和属性不能被子类重写，但子类可以继承父类静态方法和属性

##### 34.怎么确保一个集合不能被修改？

可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。

##### 35.并行和并发有什么区别？

- 并行：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。
- 并发：多个处理器或多核处理器同时处理多个任务。

##### 37.守护线程是什么？

守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。

##### 38.创建线程有哪几种方式？

- 继承 Thread 重新 run 方法；
- 实现 Runnable 接口；
- 实现 Callable 接口。

##### 40.线程有哪些状态？

线程的状态：

- NEW 新生成
- RUNNABLE 正在执行中
- BLOCKED 阻塞（被同步锁或者IO锁阻塞）
- WAITING 永久等待
- TIMED_WAITING 等待指定的时间重新被唤醒
- TERMINATED 执行完成

##### 41.sleep() 和 wait() 有什么区别？

- 类的不同：==sleep() 来自 Thread，wait() 来自 Object。==
- 释放锁：==sleep() 不释放锁；wait() 释放锁。==
- 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。

##### 42.notify()和 notifyAll()有什么区别？

- notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。
- notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争，而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。

##### 43.线程的 run() 和 start() 有什么区别？

==start() 方法用于启动线程，run() 方法用于执行线程的运行时代码==。run() 可以重复调用，而 start() 只能调用一次。

##### 44.创建线程池有哪几种方式？

线程池创建有七种方式，最核心的是最后一种：

- newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；
- newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；
- newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；
- newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；
- newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；
- newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；
- ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。

##### 45.线程池都有哪些状态？

- RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。
- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。
- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
- TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。
- TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。

##### 46.线程池中 submit() 和 execute() 方法有什么区别？

- execute()：只能执行 Runnable 类型的任务。
- submit()：可以执行 Runnable 和 Callable 类型的任务。
- Callable 类型的任务可以获取执行的返回值（future.get），而 Runnable 执行无返回值。

##### 47.在 Java 程序中怎么保证多线程的运行安全？

- 使用安全类，比如 Java. util. concurrent 下的类。
- 使用自动锁 synchronized。
- 使用手动锁 Lock。

##### 48.多线程中 synchronized 锁升级的原理是什么？

synchronized 锁升级原理：在锁对象的对象头mark word里面有一个 thread_id 字段，在第一次访问的时候 thread_id 为空，jvm 让其持有偏向锁，并将 thread_id 设置为其线程 id，再次进入的时候会先判断 thread_id 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。

锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。

##### 49.什么是死锁？怎么防止死锁？

当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。

- 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。
- 尽量使用JUC并发类代替自己手写锁。
- 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
- 尽量减少同步的代码块。

##### 51.ThreadLocal 是什么？有哪些使用场景？

ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

ThreadLocal 的经典使用场景是数据库连接和 session 管理等。

##### 52.说一下 synchronized 底层实现原理？

synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元，在 Java 6 之后，Java 虚拟机提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁。

##### 53.synchronized 和 volatile 的区别是什么？

- volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
- volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

##### 54.synchronized 和 Lock 有什么区别？

- synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
- synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
- ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；

- ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。
- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
- volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

##### 56.说一下 atomic 的原理？

==atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法，底层为cmpxchg来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。==

##### 57.什么是反射？

反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

##### 58.什么是Java序列化？什么情况下需要序列化？

Java序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。

以下情况需要使用Java序列化：

- 想把的内存中的对象状态保存到一个文件中或者数据库中时候；
- 想用套接字在网络上传送对象的时候；
- 想通过RMI（远程方法调用）传输对象的时候。

##### 59.动态代理是什么？有哪些应用？

动态代理是运行时动态生成代理类。

动态代理的应用有spring aop，Java注解对象获取，Feign的HTTP调用等。

##### 60.怎么实现动态代理？

JDK原生动态代理和cglib动态代理。

##### 61.为什么要使用克隆？

克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。

##### 62.如何实现对象克隆？

实现Cloneable接口并重写Object类中的clone()方法。实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。

##### 63.深拷贝和浅拷贝区别是什么？

- 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。
- 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。

##### 71.如何避免 SQL 注入？

- 使用预处理 PreparedStatement

- 使用正则表达式过滤掉字符中的特殊字符

##### 72.什么是 XSS 攻击，如何避免？

XSS 攻击：即==跨站脚本攻击==，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。

预防 XSS 的核心是必须==对输入的数据做过滤处理==。

##### 73.什么是 CSRF 攻击，如何避免？

CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。

防御手段：

- 验证请求来源地址
- 关键操作添加验证码
- 在请求地址添加 token 并验证。

##### 74.throw 和 throws 的区别？

throw：是真实抛出一个异常。throws：是声明可能会抛出一个异常。

##### 80.forward 和 redirect 的区别？

forward 是转发 和 redirect 是重定向：

- 地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；
- 数据共享：==forward 可以共享 request 里的数据，redirect 不能共享；==
- 效率：forward 比 redirect 效率高。

##### 85. get 和 post 请求有哪些区别？

- get 请求会被浏览器主动缓存，而 post 不会。
- get 传递参数有大小限制，而 post 没有。
- post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。

##### 99.说一下 spring 的事务隔离？

spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：

ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；

- 未提交读：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；
- 提交读：一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；
- 可重复读：保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；
- 序列化：代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。

数据库读写会出现问题：

- 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。
- 不可重复读 ：是指在一个事务内，多次读同一数据。
- 幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

##### 112.spring cloud 的核心组件有哪些？

- Eureka：服务注册与发现。
- Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。
- Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
- Hystrix：断路器的作用是当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待，这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。Hystrix提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。
- Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。

##### 125.MyBatis 中#{}和?的区别是什么？

#是预编译处理，{}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。

##### 126.MyBatis 有几种分页方式？

分页方式：逻辑分页和物理分页。

- 逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。


- 物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。


##### 127.RowBounds 是一次性查询全部结果吗？为什么？

RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更的数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。

##### 128.MyBatis 逻辑分页和物理分页的区别是什么？

逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。
		物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。

##### 129.MyBatis 是否支持延迟加载（懒加载）？原理是什么？

MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。

延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。

比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。

##### 130.说一下 MyBatis 的一级缓存和二级缓存？

- 一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。
- 二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。
- 开启二级缓存数据查询流程：二级缓存 -> 一级缓存 -> 数据库。
- 缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

##### 132.MyBatis 有哪些执行器（Executor）？

- MyBatis 有三种基本的Executor执行器：
- SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；
- ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；
- BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。

##### 133.MyBatis 分页插件的实现原理是什么？

分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

##### 135.RabbitMQ 的使用场景有哪些？

- 抢购活动，削峰填谷，防止系统崩塌。
- 延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。
- 解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。

##### 136.RabbitMQ有哪些重要的角色？

RabbitMQ中重要的角色有：生产者、消费者和代理：

- 生产者：消息的创建者，负责创建和推送数据到消息服务器；
- 消费者：消息的接收方，用于处理数据和确认消息；
- 代理：就是RabbitMQ本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。

##### 137.RabbitMQ有哪些重要的组件？

- ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。
- Channel（信道）：消息推送使用的通道。
- Exchange（交换器）：用于接受、分配消息。
- Queue（队列）：用于存储生产者的消息。
- RoutingKey（路由键）：用于把生成者的数据分配到交换器上。
- BindingKey（绑定键）：用于把交换器的消息绑定到队列上。

##### 138.RabbitMQ中vhost的作用是什么？

vhost：每个RabbitMQ都能创建很多vhost，我们称之为虚拟主机，每个虚拟主机其实都是mini版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。

##### 139.RabbitMQ的消息是怎么发送的？

首先客户端必须连接到RabbitMQ服务器才能发布和消费消息，客户端和rabbitserver之间会创建一个tcp连接，一旦tcp打开并通过了认证（认证就是你发送给rabbit服务器的用户名和密码），你的客户端和RabbitMQ就创建了一条amqp信道（channel），信道是创建在“真实”tcp上的虚拟连接，amqp命令都是通过信道发送出去的，每个信道都会有一个唯一的id，不论是发布消息，订阅队列都是通过这个信道完成的。

##### 140.RabbitMQ怎么保证消息的稳定性？

提供了事务的功能；通过将channel设置为confirm（确认）模式。

##### 141.RabbitMQ怎么避免消息丢失？

把消息持久化磁盘，保证服务器重启消息不丢失；每个集群中至少有一个物理磁盘，保证消息落入磁盘。

##### 142.要保证消息持久化成功的条件有哪些？

- 声明队列必须设置持久化durable设置为true.
- 消息推送投递模式必须设置持久化，deliveryMode设置为2（持久）。
- 消息已经到达持久化交换器。
- 消息已经到达持久化队列。
  以上四个条件都满足才能保证消息持久化成功。

##### 143.RabbitMQ持久化有什么缺点？

持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用ssd硬盘来缓解吞吐量的问题。

##### 144.RabbitMQ有几种广播类型？

- direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。
- headers：与direct类似，只是性能很差，此类型几乎用不到。
- fanout：分发模式，把消费分发给所有订阅者。
- topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。

##### 145.RabbitMQ怎么实现延迟消息队列？

延迟队列的实现有两种方式：

- 通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能
- 使用插件实现延迟功能。

##### 146.RabbitMQ集群有什么用？

集群主要有以下两个用途：

- 高可用：某个服务器出现问题，整个RabbitMQ还可以继续使用；
- 高容量：集群可以承载更多的消息量。

##### 147.RabbitMQ节点的类型有哪些？

- 磁盘节点：消息会存储到磁盘。
- 内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。

##### 148.RabbitMQ集群搭建需要注意哪些问题？

- 各节点之间使用“–link”连接，此属性不能忽略。
- 各节点使用的erlangcookie值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。
- 整个集群中必须包含一个磁盘节点。

##### 149.RabbitMQ每个节点是其他节点的完整拷贝吗？为什么？

不是，原因有以下两个：

- 存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；
- 性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。

##### 150.RabbitMQ集群中唯一一个磁盘节点崩溃了会发生什么情况？

如果唯一磁盘的磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。

##### 151.RabbitMQ对集群节点停止顺序有要求吗？

RabbitMQ对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。

##### 164.数据库的三范式是什么？

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
- 第三范式：任何非主属性不依赖于其它非主属性。

##### 165.一张自增表里面总共有7条数据，删除了最后2条数据，重启MySQL数据库，又插入了一条数据，此时id是几？

- 表类型如果是MyISAM，那id就是8。
- 表类型如果是InnoDB，那id就是6。
- InnoDB表只会把自增主键的最大id记录在内存中，所以重启之后会导致最大id丢失。

##### 166.如何获取当前数据库版本？

使用select version()获取当前MySQL数据库版本。

##### 167.说一下ACID是什么？

- Atomicity（原子性）==：一个事务（transaction）中的所有操作，或者全部完成==，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- Consistency（一致性）：==在事务开始之前和事务结束以后，数据库的完整性没有被破坏==。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
- Isolation（隔离性）：==数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（readcommitted）、可重复读（repeatableread）和串行化（Serializable）。==
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

##### 170.MySQL的内连接、左连接、右连接有什么区别？

内连接关键字：innerjoin；左连接：leftjoin；右连接：rightjoin。

内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

##### 171.MySQL索引是怎么实现的？

具体来说MySQL中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是B+树实现的，B+树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。

##### 172.怎么验证MySQL的索引是否满足需求？

使用explain查看SQL是如何执行查询语句的，从而分析你的索引是否满足需求。

explain语法：explain select* from table where type=1。

##### 173.说一下数据库的事务隔离？

MySQL的事务隔离是在MySQL.ini配置文件里添加的，在文件的最后添加：

transaction-isolation=REPEATABLE-READ

##### 174.说一下MySQL常用的引擎？

InnoDB引擎：InnoDB引擎提供了对数据库acid事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL运行的时候，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行select count(*) from table指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

MyIASM引擎：5.1之前MySQL的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和InnoDB不同的是，MyIASM引擎是保存了表的行数，于是当进行select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将MyIASM作为数据库引擎的首选。

##### 175.说一下MySQL的行锁和表锁？

MyISAM只支持表锁，InnoDB支持表锁和行锁，默认为行锁。

- 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
- 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

##### 176.说一下乐观锁和悲观锁？

- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
- 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。
- 数据库的乐观锁需要自己实现，在表里面添加一个version字段，每次修改成功值加1，这样每次修改的时候先对比一下，自己拥有的version和数据库现在的version是否一致，如果不一致就不修改，这样就实现了乐观锁。

##### 177.MySQL问题排查都有哪些手段？

- 使用show process list命令查看当前所有连接信息。

- 使用explain命令查询SQL语句执行计划。

- 开启慢查询日志，查看慢查询的SQL， 

  ```sql
  set global slow_query_log=1;
  #展示慢查询日志地址
  show variables like 'slow-query-log-file';
  #展示慢查询SQL语句
  set global long_query_time=4
  show variables like 'long_query_time';
  
  ```

##### 178.如何做MySQL的性能优化？

- 为搜索字段创建索引。
- 避免使用select*，列出需要查询的字段。
- 垂直分割分表。
- 选择正确的存储引擎。

##### 179.Redis是什么？都有哪些使用场景？

- Redis是一个使用C语言开发的高速缓存数据库。

- Redis使用场景：

  - 记录帖子点赞数、点击数、评论数
  - 缓存近期热帖
  - 缓存文章详情信息
  - 记录用户会话信息

##### 180.Redis有哪些功能？

- 数据缓存功能
- 分布式锁的功能
- 支持数据持久化
- 支持事务
- 支持消息队列

##### 181.Redis和memcache有什么区别？

- 存储方式不同：memcache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型：memcache对数据类型支持相对简单；Redis有复杂的数据类型。
- 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis自己构建了vm（虚拟内存）机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- value值大小不同：Redis最大可以达到1gb；memcache只有1mb。

##### 182.Redis为什么是单线程的？

使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。

Redis 通过 AE 事件模型以及 IO 多路复用等技术，处理性能非常高，因此没有必要使用多线程。

单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。Redis6.0后 支持多线程主要就是两个原因：

- 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核。
- 多线程任务可以分摊 Redis 同步中网络 IO 读写负荷。

##### 183.什么是缓存穿透？怎么解决？

缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

##### 184.Redis支持的数据类型有哪些？

Redis支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。

##### 185.Redis支持的Java客户端都有哪些？

支持的Java客户端有Redisson、jedis、lettuce等。

##### 186.jedis、Redisson和lettuce有哪些区别？

- Jedis
  - Redis的Java实现客户端，提供了比较全面的Redis命令的支持
  - 使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。
- redission
  - 实现了分布式和可扩展的Java数据结构，促使使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列
  - 基于Netty框架的事件驱动的通信层，其方法调用是异步的。Redisson的API是线程安全的，所以可以操作单个Redisson连接来完成各种操作
- lettuce
  - 高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器
  - 主要在一些分布式缓存框架上使用比较多基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作

##### 187.怎么保证缓存和数据库数据的一致性？

合理设置缓存的过期时间。新增、更改、删除数据库操作时同步更新Redis，可以使用事物机制来保证数据的一致性。

##### 188.Redis持久化有几种方式？

- RDB（RedisDatabase）：指定的时间间隔能对你的数据进行快照存储。
- AOF（AppendOnlyFile）：每一个收到的写命令都通过write函数追加到文件中。

##### 189.Redis怎么实现分布式锁？

Redis分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用setnx(setifnotexists)指令，只允许被一个程序占有，使用完调用del释放锁。

##### 190.Redis分布式锁有什么缺陷？

Redis分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

##### 191.Redis如何做内存优化？

尽量使用Redis的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将Web系统的用户对象，应该放到散列表里面再整体存储到Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置key进行存储。

##### 192.Redis淘汰策略有哪些？

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰。

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。

no-enviction（驱逐）：禁止驱逐数据。

##### 193.Redis常见的性能问题有哪些？该如何解决？

- 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
- Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

##### 200.如何解决topK问题？

针对top K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树或者Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K。

##### 300.nginx 和zuul 的区别

 相同点：
 		Zuul和nginx 都可以实现负载均衡。反向代理，过滤请求，实现网关效果；
		 不同点：

Nginx 采用C 语言编写；Zuul采用java 语言编写：
		 Zuul 采用ribbon+eureka实现本地负载均衡；Nginx 采用服务器端实现负载均衡。
		 Nginx比zuul 功能会强大点因为nginx可以整合一些脚本语言（nginx+lua）

nginx适合于服务器端负载均衡，也可以实现网关； ZUUL适合微服务中实现网关，而且使用技术是java 语言

最好建议nginx+zuul实现网关，其中nginx作用实现反向代理， Zuul 对微服务实现网关拦截

**1.在Mysql中使用explain来查看sql执行信息时，经常会看到Using filesort，那么Using filesort在MySQL中代表什么意思**

有人会说是外部排序，其实是不对或者不准确的。事实上Using filesort是一个非常差的命名。

真实的情况是，如果一个排序操作不能通过索引来完成，那这次排序操作就叫做filesort，这跟file没有任何关系。filesort应该叫做sort，而它的实现，就是大家熟悉的快排。

**2.什么是MVCC**

即`多版本并发控制`，主要是为了提高数据库的`并发性能`，以下文章都是围绕InnoDB引擎来讲，因为myIsam不支持事务。

同一行数据平时发生读写请求时，会`上锁阻塞`住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时`不用加锁`。

这个读是指的`快照读`，而不是`当前读`，当前读是一种加锁操作，是`悲观锁`。

**3.什么是当前读和快照读**

当前读读取的数据库记录，都是`当前最新`的`版本`，会对当前读取的数据进行`加锁`，防止其他事务修改数据。是`悲观锁`的一种操作。

快照读的实现是基于`多版本`并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前`历史版本`的数据。

**4.快照读与mvcc的关系？**

`MVCCC`是“维持一个数据的多个版本，使读写操作没有冲突”的一个`抽象概念`。这个概念需要具体功能去实现，这个具体实现就是`快照读`。

**5.数据库并发场景**

- `读-读`：不存在任何问题，也不需要并发控制
- `读-写`：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- `写-写`：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

**6.MVCC解决并发哪些问题？**

mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配`单向增长`的`时间戳`。为每个数据修改保存一个`版本`，版本与事务时间戳`相关联`。读操作`只读取`该事务`开始前`的`数据库快照`。解决问题如下：

- `并发读-写时`：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。
- 解决`脏读`、`幻读`、`不可重复读`等事务隔离问题，但不能解决上面的`写-写 更新丢失`问题。

因此有了下面提高并发性能的组合拳：

- `MVCC + 悲观锁`：MVCC解决读写冲突，悲观锁解决写写冲突
- `MVCC + 乐观锁`：MVCC解决读写冲突，乐观锁解决写写冲突

**7.MVCC的实现原理**

它的实现原理主要是`版本链`，`undo日志` ，`Read View `

- 版本链：`db_trx_id`、`db_roll_pointer`、`db_row_id`（事务ID、回滚指针、自增ID）

  `db_row_id`是数据库默认为该行记录生成的`唯一隐式主键`，`db_trx_id`是当前操作该记录的`事务ID`，而`db_roll_pointer`是一个`回滚指针`，用于配合`undo日志`，指向上一个`旧版本`。

  每次对数据库记录进行改动（除了插入），都会记录一条`undo日志`，每条undo日志也都有一个`roll_pointer`属性，可以将这些`undo日志都连起来`，`串成一个链表`

  对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个`链表`，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，在根据ReadView判断版本可见性的时候会用到。

- undo日志

  Undo log 主要用于`记录`数据被`修改之前`的日志，在表信息修改之前先会把数据拷贝到`undo log`里。

  当`事务`进行`回滚时`可以通过undo log 里的日志进行`数据还原`。

- Read View 

  事务进行`快照读`操作的时候生产的`读视图`(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个`快照`。

所谓的MVCC指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的`版本链`的过程，这样子可以使不同事务的`读-写`、`写-读`操作`并发执行`，从而`提升系统性能`。

